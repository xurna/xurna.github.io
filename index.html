
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>xurna</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Xurna Yang">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="xurna">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="xurna">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xurna">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="xurna" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="xurna" title="xurna"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="xurna">xurna</a></h1>
				<h2 class="blog-motto">Never too late to learn.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/12/fiddler/" title="fiddler调试" itemprop="url">fiddler调试</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-07-12T13:57:47.000Z" itemprop="datePublished"> 发表于 2016-07-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="利用fiddler调试"><a href="#利用fiddler调试" class="headerlink" title="利用fiddler调试"></a>利用fiddler调试</h2><p>其实我主要想讲的就是怎样利用fiddler工具进行页面js，css，html等文件的调试，fiddler的下载和安装都很简单，此处不说了。</p>
<p>为什么需要用到fiddler来调试，它主要是为了调试手机或者页面<code>存在缓存</code>或者需要在线下<code>修复bug</code>而又不影响线上表现的情况下使用。而对于调试手机以及网页上的具有缓存的文件来说，fiddler无疑是给开发者带来了福音。</p>
<h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h2><h3 id="手机调试"><a href="#手机调试" class="headerlink" title="手机调试"></a>手机调试</h3><ol>
<li><p>首先设置一下fiddler，打开tool-&gt;fidder options-&gt;connection,按照下图配置：</p>
</li>
<li><p>然后在手机端设置一下http代理，找到与电脑服务器连接同一wifi的ip地址，可在cmd中ipconfig中找到wifi的ip，电脑与手机需要在同一网段中才能成功。<br>手机的配置如下图，输入<code>服务器</code>和<code>端口</code>：</p>
</li>
<li><p>成功后在fiddler页面的左边可以看到所在进行的网络访问记录，找到你需要调试的页面，在<code>autoRespondor</code>中<code>add rules</code>,可以看到再下面出现你所选的页面，在下一个文本框中选择<code>find a file</code>，找到本地你需要进行调试的文件，然后点击<code>save</code>,如下图，最后就可以进行本地文件的修改，可以直接看到线上的效果，但是，这只是调试，最后文件调试好后还要上传你所更改过的文件。</p>
</li>
</ol>
<h3 id="pc端调试"><a href="#pc端调试" class="headerlink" title="pc端调试"></a>pc端调试</h3><p>pc端的调试不用配置手机调试中的第一步与第二部，只要完成上面的第三步即可。</p>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>fiddler除了可以调试网页外，还可以进行抓包，查看http的头部信息等，这里没怎么用到我就不说了，点到为止。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/开发工具使用/">开发工具使用</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/fiddler调试/">fiddler调试</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/23/cookieAndSession/" title="cookie和Session" itemprop="url">cookie和Session</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-06-23T02:45:36.000Z" itemprop="datePublished"> 发表于 2016-06-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="cookie定义"><a href="#cookie定义" class="headerlink" title="cookie定义"></a>cookie定义</h3><p>用户访问网络，服务器给当前客户机上创建的一个临时文件用来保存用户信息，以便用户下次继续访问该网络时，网站服务器能识别用户身份，常见cookie用来保存用户界面，用户id等资源。</p>
<h3 id="cookie的使用"><a href="#cookie的使用" class="headerlink" title="cookie的使用"></a>cookie的使用</h3><p>1.创建cookie：当前页面设置cookie不是立即生效，等下一个页面才能看到。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setcookie(<span class="string">'name'</span>,<span class="string">'mary'</span>,time()+24*60*60) //一天</span><br><span class="line">          cookie名称  cookie值  有效时间</span><br><span class="line">应用：</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">'name'</span>]&amp;&amp;<span class="variable">$_POST</span>[<span class="string">'password'</span>])&#123;</span><br><span class="line">    setcookie(<span class="string">'name'</span>,<span class="string">'mary'</span>,time()+24*60*60);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>设置有效时间，cookie会保存在硬盘里，不设置，则保存在内存里，用户关掉页面就消失了。<br>cookie是http协议头的一部分，用于浏览器和服务器之间传递信息，cookie是通过http报头发送的。</p>
<p>2.接受cookie<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_COOKIE</span>(<span class="string">'name'</span>)))&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$_COOKIE</span>(<span class="string">'name'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.删除cookie<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(<span class="string">'name'</span>,<span class="string">''</span>,time()-1);</span><br></pre></td></tr></table></figure></p>
<p>如何利用实现自动登录：<br>当用户在某个网站注册后，就会收到一个<code>惟一用户ID</code>的cookie。客户后来重新连接时，这个用户ID会自动返回，服务器对它进行检查，确定它是否为注册用户且选择了自动登录，从而使用户务需给出明确的用户名和密码，就可以访问服务器上的资源。</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h3 id="session定义"><a href="#session定义" class="headerlink" title="session定义"></a>session定义</h3><p>服务器机制，使用类似散列表的结构来保存信息，php会给每一个访问用户创建一个session id，该id<code>唯一</code>，它的存放有三种方式:<br>· url传递：安全性差<br>· 保存在客户端的cookie中：php会话机制通过设置cookie，在cookie中保存会话id（session id），在服务器会生成session文件，与用户关联。<br>· 保存在数据库中：安全，但是效率下降。</p>
<h3 id="session的使用"><a href="#session的使用" class="headerlink" title="session的使用"></a>session的使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">启动session：</span><br><span class="line">    session_start() //必须放在文件最前面</span><br><span class="line"></span><br><span class="line">创建session：</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">'name'</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">'arr'</span>] = array(<span class="string">"name"</span>=&gt;<span class="string">"hello"</span>,<span class="string">"type"</span>=&gt;<span class="string">"web"</span>);</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$_SESSION</span>[<span class="string">'name'</span>];</span><br><span class="line"></span><br><span class="line">删除session：</span><br><span class="line">    <span class="built_in">unset</span>(<span class="variable">$_SESSION</span>[<span class="string">'name'</span>]);</span><br><span class="line"></span><br><span class="line">清空用户所有的session信息：</span><br><span class="line">    session_destroy();</span><br></pre></td></tr></table></figure>
<p>当程序为某个用户创建一个session，服务器首先检查客户端请求是够包含session标识（session id），若有，则服务器按照session id把session检索出来使用；若无，则服务器创建一个session并且生成一个与此相关联的session id，这个session id将在本次响应中返回给客户端保存。</p>
<h2 id="cookie与session之间的联系"><a href="#cookie与session之间的联系" class="headerlink" title="cookie与session之间的联系"></a>cookie与session之间的联系</h2><p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于才服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上还有其他选择.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/网络/">网络</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/web存储/">web存储</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/18/rsa/" title="RSA算法" itemprop="url">RSA算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-06-18T09:20:37.000Z" itemprop="datePublished"> 发表于 2016-06-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>RSA算法被认为是目前地球上最重要的加密算法，所以作为互联网的热爱者来说，想了解一下它的神秘感，加深对网络安全方面的认识。</p>
<p>在数论那一章铺垫了很多要实现RSA算法的准备工作，现在主要讲解一下如何生成密钥。</p>
<h2 id="密钥生成步骤"><a href="#密钥生成步骤" class="headerlink" title="密钥生成步骤"></a>密钥生成步骤</h2><p>假设A要和B进行加密通信，她就需要生成公钥和私钥。公钥用来给A加密信息，私钥用来解密。</p>
<p>1.第一步，随机选择两个<code>不相等的质数p和q</code>。<br>假设A选择了61和53。（实际应用中，这两个质数越大，就越难破解。）</p>
<p>2.第二步，计算p和q的<code>乘积n</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = 61×53 = 3233</span><br></pre></td></tr></table></figure></p>
<p><code>n的长度就是密钥长度</code>。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是<code>1024</code>位，重要场合则为<code>2048</code>位。</p>
<p>3.第三步，计算n的<code>欧拉函数φ(n)</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">φ(n) = (p-1)(q-1)</span><br></pre></td></tr></table></figure></p>
<p>算出φ(3233)等于60×52，即3120。</p>
<p>4.第四步，随机选择一个<code>整数e</code>，条件是<code>1&lt; e &lt; φ(n)</code>，且<code>e与φ(n) 互质</code>。<br>在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p>
<p>5.第五步，计算e对于φ(n)的<code>模反元素d</code>。<br>所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    ed ≡ 1 (mod φ(n))</span><br><span class="line">即：</span><br><span class="line">    ed + 1 = φ(n)x</span><br><span class="line">已知 e=17, φ(n)=3120，</span><br><span class="line">所以：</span><br><span class="line">    17d +1 =3120x</span><br><span class="line">求出一组解为（d,x）=(2753,-15) ,即d = 2753</span><br></pre></td></tr></table></figure></p>
<p>至此所有计算完成。</p>
<p>6.第六步，将n和e封装成公钥，n和d封装成私钥。<br>n=3233，e=17，d=2753，所以公钥就是 <code>(3233,17)</code>，私钥就是<code>（3233, 2753）</code>。<br>实际应用中，公钥和私钥的数据都采用ASN.1格式表达（实例）。</p>
<h2 id="算法可靠性"><a href="#算法可靠性" class="headerlink" title="算法可靠性"></a>算法可靠性</h2><p>密钥生成步骤中，（n，e）是公钥，是公开的，p,q,φ(n),d是不公开的，其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。</p>
<blockquote>
<p>那么，有无可能在已知n和e的情况下，推导出d？</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</span><br><span class="line">（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</span><br><span class="line">（3）n=pq。只有将n因数分解，才能算出p和q。</span><br></pre></td></tr></table></figure>
<p>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。<br>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。</p>
<h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>（1）加密要用公钥 (n,e)<br>假设B要向A发送加密信息m，他就要用A的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。<br>所谓”加密”，就是算出下式的c：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　c = ( m^e) mod n</span><br></pre></td></tr></table></figure></p>
<p>A的公钥是 (3233, 17)，B的m假设是65，那么可以算出下面的等式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　c =( 65^17) mod 3233 =  2790</span><br></pre></td></tr></table></figure></p>
<p>c = 2790,B把2790发给A</p>
<p>（2）解密要用私钥(n,d)<br>A收到B发过来的2790后，就用自己的私钥（3233,2753）进行解密。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = (c^d) mod n</span><br><span class="line">即：</span><br><span class="line">m = (2790^2753) mod 3233 = 65</span><br></pre></td></tr></table></figure></p>
<p>A知道了B加密前的原文就是65。</p>
<p>至此，”加密–解密”的整个过程全部完成。<br>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。<br>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p>
<p>参考文章：<br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/网络安全/">网络安全</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/网安/">网安</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/18/shulun/" title="数论" itemprop="url">数论</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-06-18T07:13:53.000Z" itemprop="datePublished"> 发表于 2016-06-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h4 id="1-对称密钥"><a href="#1-对称密钥" class="headerlink" title="1.对称密钥"></a>1.对称密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）甲方选择某一种加密规则，对信息进行加密；</span><br><span class="line">（2）乙方使用同一种规则，对信息进行解密。</span><br></pre></td></tr></table></figure>
<p>这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p>
<h4 id="2-非对称密钥"><a href="#2-非对称密钥" class="headerlink" title="2.非对称密钥"></a>2.非对称密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</span><br><span class="line">（2）甲方获取乙方的公钥，然后用它对信息加密。</span><br><span class="line">（3）乙方得到加密后的信息，用私钥解密。</span><br></pre></td></tr></table></figure>
<p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p>
<h4 id="3-互质关系"><a href="#3-互质关系" class="headerlink" title="3.互质关系"></a>3.互质关系</h4><p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<code>互质关系</code>。</p>
<h4 id="4-欧拉函数"><a href="#4-欧拉函数" class="headerlink" title="4.欧拉函数"></a>4.欧拉函数</h4><blockquote>
<p>思考：任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）</p>
</blockquote>
<p>计算这个值的方法就叫做<code>欧拉函数</code>，以<code>φ(n)</code>表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。<br>φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。</p>
<p>1) 情况一<br>如果n=1，则 <code>φ(1) = 1</code> 。因为1与任何数（包括自身）都构成互质关系。</p>
<p>2) 情况二<br>如果n是质数，则 <code>φ(n)=n-1</code> 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p>
<p>3) 情况三<br>如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则<br><code>φ(p^k) = p^k - p^(k-1) = p^k(1-1/p)</code><br>比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。<br>可以看出，上面的第二种情况是 k=1 时的特例。</p>
<p>4) 情况四<br>如果n可以分解成两个互质的整数之积，<code>n = p1 * p2</code>,则<br><code>φ(n) = φ(p1p2) = φ(p1)φ(p2)</code><br>即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。</p>
<p>5) 情况五<br>因为任意一个大于1的正整数，都可以写成一系列质数的积。<br><img src="http://i4.buimg.com/6b3e3e229e10dc5c.png"><br>根据第四条结论，得到：<br><img src="http://i4.buimg.com/61b1469aca40f168.png"><br>在根据第三条结论，得到：<br><img src="http://i4.buimg.com/03f48662db7435e1.png"><br>也就等于：<br><img src="http://i4.buimg.com/9eeb98b6ff185269.png"><br>这就是<code>欧拉函数</code>的通用计算公式。比如，1323的欧拉函数，计算过程如下：<br><img src="http://i4.buimg.com/de98086e44fda3da.png"></p>
<h4 id="5-欧拉定理"><a href="#5-欧拉定理" class="headerlink" title="5.欧拉定理"></a>5.欧拉定理</h4><p>欧拉函数的用处，在于<code>欧拉定理</code>。<code>欧拉定理</code>指的是：<br>如果两个<code>正整数a和n互质</code>，则n的欧拉函数 φ(n) 可以让下面的等式成立：<br><img src="http://i2.buimg.com/0c416c4400a5eac1.png"><br>也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。</p>
<p>欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，<br><img src="http://i4.buimg.com/8f3ed8c63761f565.png"><br>已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。<br><img src="http://i4.buimg.com/bfc0fde003b8ccff.png"><br>因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。<code>7^φ(223)%10 = 1</code></p>
<p>欧拉定理有一个特殊情况:设<code>正整数a与质数p互质</code>，因为质数p的φ(p)等于p-1，则欧拉定理可以写成<br><img src="http://i4.buimg.com/b844236151ce8c8c.png"><br>这就是著名的<code>费马小定理</code>。它是欧拉定理的<code>特例</code>。<br>欧拉定理是<code>RSA算法</code>的核心。理解了这个定理，就可以理解RSA。</p>
<h4 id="6-模反元素"><a href="#6-模反元素" class="headerlink" title="6.模反元素"></a>6.模反元素</h4><p>如果两个<code>正整数a和n互质</code>，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。<br><img src="http://i4.buimg.com/c09b4116a40efee0.png"><br>这时，b就叫做a的<code>模反元素</code>。</p>
<blockquote>
<p>比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。</p>
</blockquote>
<p>计算模反元素方法：<br><code>x*n+1可以除尽a则为模反元素</code>。</p>
<p>欧拉定理可以用来证明模反元素必然存在。<br><img src="http://i4.buimg.com/cfea440761a9b6f1.png"><br>可以看到，a的 φ(n)-1 次方，就是a的模反元素。</p>
<p>参考文章：<br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/网络安全/">网络安全</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数论/">数论</a><a href="/tags/网安/">网安</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/15/androidGet/" title="安卓问题解决方案" itemprop="url">安卓问题解决方案</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-06-15T07:46:50.000Z" itemprop="datePublished"> 发表于 2016-06-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在赶安卓项目，做了一个日记app，原生安卓开发，刚入门安卓，各方面还不是很懂，但一个项目下来自己能学到很多，servlet，多线程，网络访问等等，其中也遇到不少问题，拿来与大家分享。</p>
<h2 id="问题与解决方案"><a href="#问题与解决方案" class="headerlink" title="问题与解决方案"></a>问题与解决方案</h2><ol>
<li><p>新建低版本的项目时马上出现appcompat_v7上有个红色的叉提示错误时，右键点击两个项目，（appcompat_v7和test）都要打开properties，然后取消下图3的打勾，打上4的勾<br><img src="http://i4.buimg.com/2cca03b57f472394.jpg" alt="图1"></p>
</li>
<li><p>在下图红色框中切换代码和调试模式<br><img src="http://i4.buimg.com/f18ddb5a57e66ce8.png"></p>
</li>
<li><p>如果想要使用Xutils框架的东西的话，需要进行初始化：把这个类作为安卓程序的接入点：<br><img src="http://i1.buimg.com/06b083aafdc2a435.png"><br>并且需要在AndroidManifest.xml文件里面加上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span> /&gt;（这句表示允许网络连接）</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span> /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果从其他项目复制activity到另外一个项目，只要把另一个项目里的AndroidManifest.xml里面相关模块加上就能用了，例如：<br><img src="http://i1.buimg.com/06b083aafdc2a435.png"></p>
</li>
<li><p>在服务器中建立文件夹的方式：<br>String folderPath =”images/“+user.getUserName();<br>String targetFile = request.getSession().getServletContext().getRealPath(“/“ + folderPath);<br>File dir = new File(targetFile);</p>
</li>
<li><p>安卓的TextView设置字符一定要为String类型，不然会出错，整型要转化String类型，例如：<br>String text_concern.setText(Integer.toString(concernN));</p>
</li>
<li><p>服务器出现如下问题：<br><img src="http://i1.buimg.com/eb0046c10fd54a16.png"><br>出现这个错误是因为在一个错误的包新建了servlet，然后又把这个servlet拖到其他的包里，这样就会导致web.xml里面的配置描述不匹配，然后服务器实例化servlet的时候就会导致错误。解决的办法就是把下面的那个包名描述改回来。（web.xml）<br><img src="http://i1.buimg.com/dfef586109eeef39.png"></p>
</li>
<li><p>关注列表点击闪退到登录界面，原因是忘记了传currentUser参数到日记正文，导致缺少参数出错，解决办法是在上一个页面跳转中加上需要传的参数，如：intent.putExtra(“currentuser”, currentuser);</p>
</li>
<li><p>使用ImageLoader 外部类，必须先初始化，不然会报错。初始化方法：<br>ImageLoader.getInstance().init(ImageLoaderConfiguration.createDefault(Activity.this));</p>
</li>
<li><p>MyEclipse启动本地Tomcat出错：Cannot change deployment state from ERROR to REDEPLOYING.<br>解决办法：<br>右击“项目名” –&gt;myeclipse–&gt;add and remove project deployments,然后在Server选项卡里删除出错的项目，重新部署即可，但是此时tomcat7里面的数据会丢失，所以最好先保存一份数据。</p>
</li>
<li><p>返回键的简单应用：Activity.this.finish();</p>
</li>
</ol>
<p>暂时写这么多吧，其实一些细节问题挺多的，但作为安卓入门来说却是一大收获。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/安卓/">安卓</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/30/http/" title="http协议" itemprop="url">http协议</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-04-30T03:11:44.000Z" itemprop="datePublished"> 发表于 2016-04-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>面试前端的时候有时会提到网络方面的问题，趁热打铁，温习一下关于http相关知识。</p>
<h2 id="认识http"><a href="#认识http" class="headerlink" title="认识http"></a>认识http</h2><p><code>http（超文本传输协议）</code>是一个基于<code>请求与响应模式</code>的、<code>无状态的</code>、<code>应用层</code>的协议，常基于<code>TCP</code>的连接方式。<br>http的特点：</p>
<ol>
<li>使用面向连接的<code>TCP作为运输层协</code>，保证数据可靠性。</li>
<li><code>无连接</code>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li><code>无状态</code>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<p>http协议通常承载与TCP协议之上，有时也承载于<code>TLS</code>或者<code>SSL</code>协议层之上，这个时候，就变成常见的<code>HTTPS</code>。默认http端口号是<code>80</code>，https的端口号是<code>443</code>.<br><img src="http://i2.buimg.com/3adbbc37b41db444.jpg" alt="http协议"></p>
<h2 id="http版本"><a href="#http版本" class="headerlink" title="http版本"></a>http版本</h2><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><p>http1.0是无连接方式，所以浏览器每次发送http请求，就会建立一条TCP连接，等待服务器端响应后，这条连接就会断开。等下次再有请求的时候，需要再建立一条TCP连接，这样导致每次有2倍RTT往返时间（TCP占一个RTT,HTTP请求与响应占一个RTT），增加了网络开销。</p>
<p>好在浏览器都提供了嫩能够打开5-10个并行的TCP连接，而每一个连接处理客户的一个请求。因此，使用并行TCP连接可以缩短响应时间。</p>
<h3 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h3><p>http1.1改进了http1.0的缺点，http1.1采用<code>持续连接</code>，即只要建立一个TCP连接，就可以在这条连接上进行复用。优点是可以减少重复进行TCP三次握手的开销，提高效率。<br>http1.1分为两类：</p>
<ol>
<li>非流水线方式：在同一个TCP连接中，新的请求需要等上次请求的响应后，才能发送。因此，在TCP连接建立以后，客户每访问一次对象就要用去一个往返时间RTT，这比非持续连接的两倍RTT的开销节省了建立TCP连接所需的一个RTT时间。</li>
<li>流水线方式：在同一个TCP连接中，客户在收到http响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可以连续发送响应报文。使用流水线方式时，客户访问所有的对象只需花费一个RTT的时间，使TCP连接中的空闲时间减少，提高下载文档的速度。</li>
</ol>
<h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><p>http2.0提出<code>服务器推</code>的概念，服务器可以对一个客户端的请求发送多个响应，除了最初的请求外，还会额外想客户端推送资源，而无需客户端明确请求，客户端还可以缓存资源。</p>
<p>http2.0的请求都在一条TCP连接上，允许多个信息在一条连接上同时交叉，采用并行双向字节流的请求和响应，只使用一个连接，可以并行交错发送请求和响应。</p>
<p>增加了首部压缩，即使非常小的请求，其请求与响应的header都只会占用很小比例的带宽。</p>
<h2 id="http请求与响应报文格式"><a href="#http请求与响应报文格式" class="headerlink" title="http请求与响应报文格式"></a>http请求与响应报文格式</h2><p>http请求报文和响应报文都是由<code>开始行</code>，<code>首部行</code>，<code>实体主体</code>，而请求与响应报文的不同在于<code>开始行</code>不一样。</p>
<h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><p>请求行 = <code>方法</code> + <code>请求资源的URL</code> + <code>http版本</code> + [回车换行CRLF]<br>例子如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.htm HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">If-Modified-Since: Wed, 17 Oct 2016 02:15:55 GMT</span><br><span class="line">If-None-Match: W/<span class="string">"158-1192587355000"</span></span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)</span><br><span class="line">Host: 192.168.2.162:8080</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure></p>
<h3 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h3><p>状态行 = <code>http版本</code> + <code>状态码</code> + <code>解释状态码的简单短语</code> + [回车换行CRLF]<br>例子如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">ETag: W/<span class="string">"158-1192590101000"</span></span><br><span class="line">Last-Modified: Wed, 17 Oct 2016 03:01:41 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 158</span><br><span class="line">Date: Wed, 17 Oct 2016 03:01:59 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　http网络这块对于理解前端优化，服务器端优化来说还是很有必要的，理解后很多东西就豁然开朗了，所以说基础知识还是要打牢，并且随着互联网的发展，新出的技术可以使以前一些繁琐的处理变得简单甚至变得没有必要。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/网络/">网络</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/网络/">网络</a><a href="/tags/http/">http</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/15/dns-search/" title="DNS查找过程" itemprop="url">DNS查找过程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-04-15T01:36:46.000Z" itemprop="datePublished"> 发表于 2016-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这几天看了一些关于网络方面的知识，总结一下<code>域名系统DNS(Domain Name System)</code>的查找过程。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义很容易理解：DNS就是用来把便于人们使用的机器名字转换成ip地址。</p>
<p><code>域名结构</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     mail.qq.com</span><br><span class="line">    /     |     \</span><br><span class="line">三级域名.二级域名.顶级域名</span><br></pre></td></tr></table></figure></p>
<p><code>域名服务器</code>；</p>
<ol>
<li>根域名服务器：最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先求助根域名服务器。在很多情况下，根域名服务器并不直接把待查询的域名直接解析出IP地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。</li>
<li>顶级域名服务器：负责管理在该顶级域名服务器注册的二级域名。</li>
<li>权限域名服务器：负责一个“区”的域名服务器。</li>
<li>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。</li>
</ol>
<p><code>DNS查询方式分类</code>：</p>
<ol>
<li>递归查询：主机所询问的本地域名服务器不知道被查询的域名ip地址，那么本地服务器就以DNS客户的身份，向其他的根域名服务器继续发出查询请求报文，不论成功与否，都会做出对应的响应。（发生在DNS客户端与DNS服务器之间）<br><img src="http://i4.buimg.com/87fdd686bd1af0bd.jpg" alt="递归查询"></li>
<li>迭代查询：DNS服务器根据自己的高速缓存或区域的数据，以最佳结果响应。如果DNS服务器无法解析，它可能返回一个指针。指针指向下级域名的DNS服务器，继续该过程。知道找到拥有所查询名字的DNS服务器，或者出错，超时为止。（发生在DNS服务器之间）<br><img src="http://i4.buimg.com/ec9da5e10bde8744.jpg" alt="迭代查询"></li>
</ol>
<h2 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h2><p>假设主机想查询另一个主机的www.163.com的IP地址，则查询步骤如下：</p>
<ol>
<li>主机向本地DNS服务器进行递归查询，浏览器检查缓存中有没有这个域名对应的解析过的ip地址，如果缓存中有，则查询过程结束。</li>
<li>否则本地服务器采用迭代查询。它先向一个根域名服务器查询，全球只有13台根域名服务器。</li>
<li>根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.com的IP地址。</li>
<li>本地域名服务器向顶级域名服务器dns.com进行查询。</li>
<li>顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的权限服务器dns.163.com的IP地址。</li>
<li>本地域名服务器向权限域名服务器dns.163.com进行查询。</li>
<li>权限域名服务器dns.163.com告诉本地域名服务器，所查询的主机的IP地址。</li>
<li>本地域名服务器最后把查询结果告诉主机。<br>引用别人的一张图片：<br><img src="http://i4.buimg.com/0ebd847531d57f06.jpg" alt="DNS查询过程"></li>
</ol>
<p>整个查询过程共用到了8个UDP报文。<br>为了提高DNS查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/网络/">网络</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/网络/">网络</a><a href="/tags/DNS/">DNS</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/11/module3/" title="模块化开发(三)" itemprop="url">模块化开发(三)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-04-11T13:22:41.000Z" itemprop="datePublished"> 发表于 2016-04-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>上两篇博客中提到的<code>AMD``CMD</code>都是浏览器端的模块开发方案，而<code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。Node.JS首先采用了js模块化的概念。</p>
<p>根据<code>CommonJS</code>规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为<code>global</code>对象的属性。</p>
<p>输出模块变量的最好方法是使用<code>module.exports</code>对象。</p>
<p>加载模块使用<code>require</code>方法，该方法读取一个文件并执行，最后返回文件内部的<code>module.exports</code>对象(之前所用的exports其实是module.exports的一个引用,<a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="external">详情</a>)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var i = 0;</span><br><span class="line">var max = 30;</span><br><span class="line"></span><br><span class="line">module.exports = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">for</span> (i; i++ &lt; max; ) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  max * = 1.1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码通过<code>module.exports</code>对象，定义了一个函数，该函数就是模块外部与内部通信的桥梁。<br>加载模块使用<code>require</code>方法，该方法读取一个文件并执行，最后返回文件内部的<code>module.exports</code>对象。</p>
<p>为什么<code>CommonJS</code>适用于服务器端呢？需要分析一下浏览器端的js和服务器端js都主要做了哪些事，有什么不同了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------服务器端JS   |    浏览器端JS-------------------------------</span><br><span class="line"></span><br><span class="line">                      相同的代码需要多次执行  |    代码需要从一个服务器端分发到多个客户端执行</span><br><span class="line"></span><br><span class="line">                        CPU和内存资源是瓶颈   |    带宽是瓶颈</span><br><span class="line"></span><br><span class="line">                         加载时从磁盘中加载   |    加载时需要通过网络加载</span><br></pre></td></tr></table></figure>
<p><code>CommonJS</code>加载模块是<code>同步</code>的，所以只有加载完成才能执行后面的操作。像<code>Node.js</code>主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以<code>CommonJS</code>规范比较适用。但如果是浏览器环境，要从服务器加载模块，这时就必须采用异步模式。所以就有了 <code>AMD</code>  <code>CMD</code> 解决方案。</p>
<p>不过，<code>Node.js</code>还没有看咧，待我学好了再来深入了解这个规范吧~~</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/模块化/">模块化</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/11/module2/" title="模块化开发(二)" itemprop="url">模块化开发(二)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-04-11T12:14:37.000Z" itemprop="datePublished"> 发表于 2016-04-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><p><a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="external">CMD规范文档</a><br><code>CMD</code>（Common Module Definition） <code>通用模块定义</code>。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。<br><code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。<br>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">  // 模块代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>define方法在执行时，默认会传入三个参数：<code>require</code>、<code>exports</code> 和 <code>module</code>。如果需要一个文件中加载多个define()函数，则需要定义模块名。<br><code>require</code>是可以把其他模块导入进来的一个参数，而<code>export</code>是可以把模块内的一些属性和方法导出的。</p>
<h2 id="seajs模块引入与自定义（手打RequireJS相关代码地址）"><a href="#seajs模块引入与自定义（手打RequireJS相关代码地址）" class="headerlink" title="seajs模块引入与自定义（手打RequireJS相关代码地址）"></a>seajs模块引入与自定义（<a href="https://github.com/xurna/module" target="_blank" rel="external">手打RequireJS相关代码地址</a>）</h2><p>与<code>require.js</code>类似，<code>seajs</code>使用<code>base</code>作为根目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">seajs.config(&#123;</span><br><span class="line">    base:<span class="string">"./js"</span>,</span><br><span class="line">    <span class="built_in">alias</span>:&#123;</span><br><span class="line">        <span class="string">"range"</span>:<span class="string">"module/range.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">seajs.use(<span class="string">"app.js"</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="主模块加载"><a href="#主模块加载" class="headerlink" title="主模块加载"></a>主模块加载</h3><p>与<code>require.js</code>不同，seajs加载模块的时候，<code>require</code>函数是写在<code>define</code>函数里面的，下面的例子，其实可以不用写上模块名和依赖模块（模块名要把 ID 定为文件路<a href="https://github.com/seajs/seajs/issues/930" target="_blank" rel="external">理由</a>）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"app"</span>,[<span class="string">"module/drag"</span>,<span class="string">"module/scale"</span>],<span class="keyword">function</span> (require,exports,module)&#123;</span><br><span class="line">    var oInput = document.getElementById(<span class="string">'input1'</span>);</span><br><span class="line">    var oDiv1 = document.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">    var oDiv2 = document.getElementById(<span class="string">'div2'</span>);</span><br><span class="line">    var oDiv3 = document.getElementById(<span class="string">'div3'</span>);</span><br><span class="line"></span><br><span class="line">    require(<span class="string">"module/drag.js"</span>).drag(oDiv3);</span><br><span class="line">    oInput.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    	oDiv1.style.display = <span class="string">"block"</span>;</span><br><span class="line">    	require(<span class="string">"module/scale.js"</span>).scale(oDiv1,oDiv2);</span><br><span class="line">    	//require 是同步往下执行，require.async 则是异步回调执行。require.async 一般用来加载可延迟异步加载的模块。</span><br><span class="line">    	require.async(<span class="string">"module/scale.js"</span>,<span class="keyword">function</span>(ex)&#123;</span><br><span class="line">    		ex.scale(oDiv1,oDiv2);</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>注意，有时你想使用 require 来进行条件加载：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        require(<span class="string">"module-A"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        require(<span class="string">"module-B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是，require无法完成条件加载,从静态分析的角度来看，这个模块同时依赖 module-A 和 module-B 两个模块，加载器会把这两个模块文件都下载下来。 这种情况下，推荐使用 require.async 来进行条件加载。</p>
<p>其实区别就是一点，require模块的加载过程是发生在模块源码分析期; require.async加载发生在模块执行期。</p>
<h2 id="AMD和CMD"><a href="#AMD和CMD" class="headerlink" title="AMD和CMD"></a>AMD和CMD</h2><blockquote>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
</blockquote>
<p>对于依赖的模块，<code>AMD</code> 是提前执行，<code>CMD</code> 是延迟执行。</p>
<blockquote>
<p>AMD:提前执行（异步加载：依赖先执行）+延迟执行<br>CMD:延迟执行（运行到需加载，根据顺序执行）</p>
</blockquote>
<p>CMD 推崇依赖就近，AMD 推崇依赖前置。看如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">var a = require(<span class="string">'./a'</span>)</span><br><span class="line">a.doSomething()</span><br><span class="line"></span><br><span class="line">var b = require(<span class="string">'./b'</span>) // 依赖可以就近书写</span><br><span class="line">b.doSomething()</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// AMD 默认推荐的是</span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123; // 依赖必须一开始就写好</span><br><span class="line">a.doSomething()</span><br><span class="line"></span><br><span class="line">b.doSomething()</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>另外一个区别是：</p>
<blockquote>
<p>AMD:API根据使用范围有区别，但使用同一个api接口<br>CMD:每个API的职责单一</p>
</blockquote>
<p>AMD的优点是：异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。<br>CMD的机制则不同，这种加载方式会产生错误，如果能规范化模块内容形式，也可以</p>
<p><code>RequireJS</code> 和 <code>Sea.js</code> 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。</p>
<p><code>SeaJS</code>与<code>RequireJS</code>最大的区别：</p>
<blockquote>
<p><code>SeaJS</code>对模块的态度是懒执行, 而<code>RequireJS</code>对模块的态度是预执行。</p>
</blockquote>
<p>RequireJS的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码, 因此执行结果只会”停顿”1次, 完成整个过程是会比SeaJS要快.</p>
<p>而SeaJS一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析, 这里耗费了时间, 所以说的SeaJS是”懒执行”.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/模块化/">模块化</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/10/module/" title="模块化开发(一)" itemprop="url">模块化开发(一)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xurna Yang" target="_blank" itemprop="author">Xurna Yang</a>
		
  <p class="article-time">
    <time datetime="2016-04-10T14:02:21.000Z" itemprop="datePublished"> 发表于 2016-04-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="先知先觉"><a href="#先知先觉" class="headerlink" title="先知先觉"></a>先知先觉</h2><p>随着前端项目越来越复杂，使用模块化开发可以提高代码的重用性，并且使项目结构清晰化。一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。</p>
<p>目前，通行的js模块规范主要由三种：<code>AMD</code>,<code>CMD</code>,<code>CommonJS</code>.</p>
<p>简单来说，就是使用<code>define</code>定义模块，使用<code>require</code>调用模块。</p>
<p>先盗用一张图来方便理解他们的异同：<br><img src="http://i2.piimg.com/090c6bf8a4da2cad.png" alt="module"></p>
<h2 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h2><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD规范文档</a><br><code>AMD</code> 即<code>Asynchronous Module Definition</code>，中文名是<code>异步模块定义</code>的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是<code>CommonJS</code></p>
<p>模块将被<code>异步加载</code>，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。</p>
<p><code>AMD</code> 是<code>RequireJS</code> 在推广过程中对模块定义的规范化的产出。</p>
<p>优点：</p>
<ol>
<li>实现js文件的异步加载，避免网页失去响应；</li>
<li>管理模块之间的依赖性，便于代码的编写和维护。</li>
</ol>
<p>目前，实现AMD的库有<code>RequireJS</code> 、<code>curl</code> 、<code>Dojo</code>  、<code>Nodules</code> 等。</p>
<h3 id="define-函数"><a href="#define-函数" class="headerlink" title="define() 函数"></a>define() 函数</h3><p>AMD规范只定义了一个函数 define，它是<code>全局变量</code>。函数的描述为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p>
<p>依赖dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。<br>依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。</p>
<p>工厂方法factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。<br>(来自-<a href="https://segmentfault.com/a/1190000000733959#articleHeader8" target="_blank" rel="external">segment</a>)</p>
</blockquote>
<p>模块名用来<code>唯一标识</code>定义中模块，它们同样在依赖性数组中使用，当一个文件中有多个define定义时，需要使用文件路径作为模块名来区分调用的模块是哪个。</p>
<p>模块名可以为 “相对的” 或 “顶级的”。如果首字符为“.”或“..”则为相对的模块名；如果你定义了根目录（<code>baseUrl</code>），那么顶级的模块名从根命名空间的概念模块解析.</p>
<p>函数定义例子：创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"alpha"</span>, [<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"beta"</span>], <span class="keyword">function</span> (require, exports, beta) &#123;</span><br><span class="line">       exports.verb = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">           <span class="built_in">return</span> beta.verb();</span><br><span class="line">           //Or:</span><br><span class="line">           <span class="built_in">return</span> require(<span class="string">"beta"</span>).verb();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p>
<p>RequireJS默认假定所有的依赖资源都是js脚本，因此无需在module ID上再加”.js”后缀，RequireJS在进行module ID到path的解析时会自动补上后缀。</p>
<h3 id="require-函数"><a href="#require-函数" class="headerlink" title="require() 函数"></a>require() 函数</h3><p>可以看下面的实际例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([<span class="string">'jquery'</span>,<span class="string">'underscore'</span>,<span class="string">'backbone'</span>],<span class="keyword">function</span>($, _, Backbone)&#123;</span><br><span class="line">	console.log($(<span class="string">".box"</span>).width());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>require()函数接受两个参数。第一个参数是一个<code>数组</code>，表示所依赖的模块，上例就是<code>[&#39;jquery&#39;, &#39;underscore&#39;, &#39;backbone&#39;]</code>，即主模块依赖这三个模块；第二个参数是一个<code>回调函数</code>，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。require()异步加载<code>jquery</code>，<code>underscore</code>和<code>backbone</code>，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<h2 id="RequireJS模块的加载（手打RequireJS相关代码地址）"><a href="#RequireJS模块的加载（手打RequireJS相关代码地址）" class="headerlink" title="RequireJS模块的加载（手打RequireJS相关代码地址）"></a>RequireJS模块的加载（<a href="https://github.com/xurna/module" target="_blank" rel="external">手打RequireJS相关代码地址</a>）</h2><h3 id="调用require-js"><a href="#调用require-js" class="headerlink" title="调用require.js"></a>调用require.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<h3 id="模块加载自定义"><a href="#模块加载自定义" class="headerlink" title="模块加载自定义"></a>模块加载自定义</h3><p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<p>如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　<span class="string">"jquery"</span>: <span class="string">"lib/jquery.min"</span>,</span><br><span class="line">　　　　　　<span class="string">"underscore"</span>: <span class="string">"lib/underscore.min"</span>,</span><br><span class="line">　　　　　　<span class="string">"backbone"</span>: <span class="string">"lib/backbone.min"</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>
<p>另一种则是直接改变基目录（baseUrl）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">　　　　baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　<span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,</span><br><span class="line">　　　　　　<span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">　　　　　　<span class="string">"backbone"</span>: <span class="string">"backbone.min"</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意一点，如果加载require.js模块的时候出现<code>timeout</code>现象，解决办法：只要在config里面加上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>Seconds: 0, //解决timeout问题</span><br></pre></td></tr></table></figure></p>
<p>除了paths，还有shim用来加载非规范的模块，可以<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">查看相关信息</a>.</p>
<h3 id="AMD模块的写法"><a href="#AMD模块的写法" class="headerlink" title="AMD模块的写法"></a>AMD模块的写法</h3><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。<br>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。<br>假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">　　define(<span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　var add = <span class="keyword">function</span> (x,y)&#123;</span><br><span class="line">　　　　　　<span class="built_in">return</span> x+y;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　<span class="built_in">return</span> &#123;</span><br><span class="line">　　　　　　add: add</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>
<p>加载方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">　　require([<span class="string">'math'</span>], <span class="keyword">function</span> (math)&#123;</span><br><span class="line">　　　　alert(math.add(1,1));</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果这个模块被其他模块依赖，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//myLib.js</span><br><span class="line">define([<span class="string">'../module/math'</span>],<span class="keyword">function</span>(math)&#123;</span><br><span class="line">	<span class="built_in">return</span> math.add(1,1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p>
<p>先写到这吧，有点累了，下次接着写。</p>
<p>参考文章：<br>1.<a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="external">https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88</a>)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/模块化/">模块化</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Blog/" title="Blog">Blog<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/安卓/" title="安卓">安卓<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开发工具使用/" title="开发工具使用">开发工具使用<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/网络/" title="网络">网络<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/网络安全/" title="网络安全">网络安全<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/重构/" title="重构">重构<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/模块化/" title="模块化">模块化<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/网络/" title="网络">网络<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/blog/" title="blog">blog<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/hexo/" title="hexo">hexo<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/css/" title="css">css<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/网安/" title="网安">网安<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/闭包/" title="闭包">闭包<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/移动端/" title="移动端">移动端<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/DNS/" title="DNS">DNS<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/http/" title="http">http<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/android/" title="android">android<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/数论/" title="数论">数论<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/fiddler调试/" title="fiddler调试">fiddler调试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/web存储/" title="web存储">web存储<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ajax/" title="ajax">ajax<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.quantacenter.com/" target="_blank" title="(量子）信息技术服务中心">Quanta</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Welcome to my blog , I&#39;m Xurna Yang from GDUFS. <br/>
			A programmer in QuantaCenter</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2696740840" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/xurna" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:565627595@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Xurna Yang">Xurna Yang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
